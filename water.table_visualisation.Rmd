
---
title: "Water table data visualisation graphs"
author: Alizée Girard
date: 2024-12-23
output: pdf_document
---

```{=html}
<!-- Notes :

Raw (calibrated) data
Autres codes :
pdf_document 

<!-- https://bookdown.org/yihui/rmarkdown-cookbook/working-directory.html
Sometimes you may want to use another directory as the working directory. The usual way to change the working directory is setwd(), but please note that setwd() is not persistent in R Markdown (or other types of knitr source documents), which means setwd() only works for the current code chunk, and the working directory will be restored after this code chunk has been evaluated. -->
```


```{r, message = FALSE, include = FALSE}
# setwd("~/Documents/Doctorat/_R.&.Stats_PhD") # fonctions utiles et working directory
# sys.source("general.scripts/fonctions.R") # envir = knitr::knit_global())
# load("~/Documents/Doctorat/_R.&.Stats_PhD/connectivite/data/raw/metadata_all.RDS")

#### bibliotheques a charger (installer avant si pas fait)
if (!require("conflicted")) install.packages("conflicted")
if (!require("dplyr")) install.packages("dplyr") # pour manipulation donnees (pipe, etc)
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("gridExtra")) install.packages("gridExtra") # multiplot()
if (!require("stringr")) install.packages("stringr") # str_to_title
if (!require("grDevices")) install.packages("grDevices") # pdf()

##### importer et préparer donnees dans R
ll.clean <- readRDS("connectivite/data/clean/ll.clean.RDS")
# obtenu via le script "/scripts/data_water.table.all.R"
```

``` {r, echo = FALSE} 
for (i in 1:length(ll.clean)) {
  paste(i)
  # extraire no de sonde
  texte <- ll.clean[[i]]$metadata[4]
  numbers <- gregexpr("[0-9]+", texte)
  result <- regmatches(texte, numbers)
  (probe.serial.no.i <- as.numeric(unlist(result)))
  
  # extraire nom de transect/puits
  cal.data <- read.csv("connectivite/data/raw/level.logger.calibration.all.csv", sep = ";")
  colnames(cal.data)
  transect.id.i.pre <- cal.data$well.id[cal.data$probe.serial.no == probe.serial.no.i]
  transect.id.i <- unique(transect.id.i.pre[!is.na(transect.id.i.pre)])
  
  # extraire nom de site
  site.name.pre <- sub("SiteName","",ll.clean[[i]]$metadata[1])
  site.name.pre.1 <- gsub(",", "", site.name.pre) # ici ce serait ST-HENRI, ça me gosse
  site.name <- str_to_title(site.name.pre.1)
  
  # créer objet contenant les données
  ll.cal <- ll.clean[[i]]$data # ll.cal ce sont les données calibrées finales, reprise du nom dans le script d'origine "data_water.table.all.R"
  # class(ll.cal); head(ll.cal); str(ll.cal); colnames(ll.cal)
  ll.cal$date.time.tz.orig <- as.POSIXct(ll.cal$date.time.tz.orig, tryFormats = )

  # graphiques de nappe phréatique
  graph.wt <- ll.cal %>% ggplot(mapping = aes(y = calibrated.value.mm/10, x = date.time.tz.orig)) + # doit être en as.POSICct, mais avec la date et l'heure. Repartir de zéro dans le script water.tanle_all??
    geom_line(group = 1) +
    scale_x_datetime(
      date_minor_breaks = "day", date_breaks = "2 weeks", date_labels = "%D:%H") +
    ggtitle(paste0(site.name, ", sonde no ", probe.serial.no.i, " à l'emplacement ", transect.id.i, "\n",
                   "nombre de ligne du fichier : ", nrow(ll.cal))) +
    labs(y = "Hauteur de nappe phréatique (cm)", x = "Date") +
    theme_bw() + theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.5))
  print(graph.wt) # imprimer dans R
  
  # ATTENTION !! surpasser consciemment dans la boucle
  # ggsave(paste0("connectivite/output/figures/",site.name, "_", probe.serial.no.i, "_", transect.id.i,".pdf"), graph.wt, width = 12, height = 8)
}
```
```{r, include = FALSE}

# Afficher tous les graphiques

# pdf("filename.pdf", width = 8, height = 12) # Open a new pdf file
# n <- length(graph.wt)
# nCol <- floor(sqrt(n))
# do.call("grid.arrange", c(graph.wt, ncol=nCol))
# dev.off() # Close the file


# if(paste0('Elevation_Inkerman_graph', transect[i],'.png') %in% list.files("connectivite/output/figures"))  { # si TRUE = STOP et warning // si FALSE = continuer la boucle (donc rien, donc IF statement)
#   stop("Attention, un fichier du même nom se trouve dans le dossier. En outrepassant cet avertissement, le fichier ancier sera effacé et remplacé.")
# } else { ggplot2::ggsave(paste0('output/figures/Elevation_Inkerman_graph',transect[i],'.png'), graph, width = 4.7, height = 2.4)  }



# # Check if the file does not exist
# file_to_check <- paste0('output/figures/Elevation_Inkerman_graph',transect[i],'.png')
# if(!file.exists(file_to_check)){ # si c'est PAS VRAI (le file n'existe pas, on poursuit) = VRAI, si c'est VRAI = FAUX (else if -> message d'erreur, empêche d'écraser)
#   ggplot2::ggsave(paste0('output/figures/Elevation_Inkerman_graph',transect[i],'.png'), graph, width = 4.7, height = 2.4)
#
#   # otherwise print a message
# }else if(file.exists(file_to_check)){
#
#   stop("The file already exists in the current directory!")
# }
# Choix CONSCIENT d'écraser
# ggplot2::ggsave(paste0('output/figures/Elevation_Inkerman_graph',transect[i],'.png'), graph, width = 4.7, height = 2.4)
```



